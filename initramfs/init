#!/bin/sh
# =============================================================
#  NextOS initramfs /init
#  Purpose: Early userspace boot — mount rootfs, switch_root
#  Runs as PID 1 directly after kernel decompresses initramfs
#
#  FIX #1 — PATH must be set explicitly. The kernel launches
#  /init with a bare environment; /sbin (switch_root, losetup,
#  modprobe) is NOT in PATH unless we set it here.
# =============================================================
export PATH=/bin:/sbin:/usr/bin:/usr/sbin

# ── 1. Banner ─────────────────────────────────────────────────
echo ""
echo "  _  _           _    ___  ___"
echo " | \| |_____ __ | |_ / _ \/ __|"
echo " | .\` / -_) \ / |  _| (_) \__ \\"
echo " |_|\_\___/_\_\  \__|\___/|___/"
echo ""
echo "  NextOS initramfs v1.1 — booting..."
echo ""

# ── 2. Mount essential virtual filesystems ────────────────────
# The kernel may already have devtmpfs on /dev (DEVTMPFS_MOUNT=y)
# but we attempt all mounts defensively — errors are suppressed.
mount -t proc     proc     /proc
mount -t sysfs    sysfs    /sys
mount -t devtmpfs devtmpfs /dev 2>/dev/null || \
    mount -t tmpfs tmpfs   /dev

mkdir -p /dev/pts
mount -t devpts devpts /dev/pts 2>/dev/null

# ── 3. Ensure critical device nodes exist ─────────────────────
# devtmpfs should create these; be defensive in case it didn't.
[ -e /dev/console ] || mknod /dev/console c 5  1
[ -e /dev/null    ] || mknod /dev/null    c 1  3
[ -e /dev/zero    ] || mknod /dev/zero    c 1  5
[ -e /dev/tty     ] || mknod /dev/tty     c 5  0
[ -e /dev/tty1    ] || mknod /dev/tty1    c 4  1
[ -e /dev/random  ] || mknod /dev/random  c 1  8
[ -e /dev/urandom ] || mknod /dev/urandom c 1  9
# Loop devices — needed to mount rootfs.img from ISO
for i in 0 1 2 3 4 5 6 7; do
    [ -e "/dev/loop$i" ] || mknod "/dev/loop$i" b 7 $i
done

# ── 4. Run mdev to populate /dev from sysfs ───────────────────
# FIX #6 — mdev -s triggers a synchronous scan of /sys and
# creates device nodes for everything the kernel already knows
# about (including sr0, sda, loop*). Without this, hotplug
# devices that fire uevents after init starts are invisible.
mdev -s 2>/dev/null || true

# ── 5. Kernel module loading ──────────────────────────────────
# These are compiled =y (built-in) in the reference kernel config,
# so modprobe is a no-op. Kept here as a safety net for kernels
# where they may be modules — the calls are silent on failure.
for mod in iso9660 loop ext4 ext3 squashfs cdrom; do
    modprobe "$mod" 2>/dev/null || true
done

# ── 6. Wait for devices to settle ────────────────────────────
# FIX #6 (part 2) — optical drives and virtio-blk can appear
# several hundred milliseconds after init starts. We poll rather
# than using a fixed sleep so we don't wait unnecessarily.
SETTLE_WAIT=0
until [ -b /dev/sr0 ] || [ -b /dev/sda ] || [ $SETTLE_WAIT -ge 5 ]; do
    sleep 1
    SETTLE_WAIT=$((SETTLE_WAIT + 1))
    mdev -s 2>/dev/null || true
done

# ── 7. Parse kernel command line ──────────────────────────────
# Supports: nextos.rootfs=<path>  (default: /boot/rootfs.img)
ROOTFS_PATH="/boot/rootfs.img"
ROOT_MOUNT_OPT="rw"
for arg in $(cat /proc/cmdline); do
    case "$arg" in
        nextos.rootfs=*) ROOTFS_PATH="${arg#nextos.rootfs=}" ;;
        ro|rw)           ROOT_MOUNT_OPT="$arg" ;;
    esac
done

echo "[init] Kernel cmdline: $(cat /proc/cmdline)"
echo "[init] Expecting rootfs at: $ROOTFS_PATH"

# ── 8. Probe all optical + block devices for the boot ISO ─────
ROOT_MOUNTED=0

# Build candidate list — optical first, then storage
CANDIDATES=""
for dev in sr0 sr1 sr2 sda sda1 sdb sdb1 hda hdc vda vda1; do
    [ -b "/dev/$dev" ] && CANDIDATES="$CANDIDATES /dev/$dev"
done

if [ -z "$CANDIDATES" ]; then
    echo "[init] WARNING: No block/optical devices found in /dev!"
    echo "[init] Listing /dev:"
    ls /dev
fi

for ISO_DEV in $CANDIDATES; do
    echo "[init] Trying ISO device: $ISO_DEV"

    # Attempt ISO9660 mount (read-only — it is a CD/ISO image)
    if mount -t iso9660 -o ro "$ISO_DEV" /mnt/iso 2>/dev/null; then
        echo "[init] Mounted ISO from $ISO_DEV"

        # Verify rootfs image is present on the ISO
        if [ -f "/mnt/iso${ROOTFS_PATH}" ]; then
            echo "[init] Found rootfs image at /mnt/iso${ROOTFS_PATH}"

            # FIX #5 — use losetup -f to find the first FREE loop device.
            # Manually iterating loop0..5 fails silently if any are in use.
            LOOP_DEV=$(losetup -f 2>/dev/null)
            if [ -z "$LOOP_DEV" ]; then
                echo "[init] ERROR: No free loop device (losetup -f returned empty)."
                umount /mnt/iso 2>/dev/null
                continue
            fi

            if losetup "$LOOP_DEV" "/mnt/iso${ROOTFS_PATH}" 2>/dev/null; then
                echo "[init] Attached rootfs.img to $LOOP_DEV"

                # Mount the ext4 rootfs read-write so /tmp, /run, etc. work
                if mount -t ext4 -o rw "$LOOP_DEV" /mnt/root 2>/dev/null; then
                    echo "[init] Root filesystem mounted successfully."
                    ROOT_MOUNTED=1
                    break
                else
                    echo "[init] WARNING: ext4 mount failed on $LOOP_DEV."
                    echo "[init] (Check rootfs.img was created with mkfs.ext4)"
                    losetup -d "$LOOP_DEV" 2>/dev/null
                fi
            else
                echo "[init] ERROR: losetup failed for $LOOP_DEV."
            fi
        else
            echo "[init] rootfs.img not found at /mnt/iso${ROOTFS_PATH} on $ISO_DEV."
            echo "[init] ISO contents:"
            ls /mnt/iso/boot/ 2>/dev/null || ls /mnt/iso/ 2>/dev/null
        fi

        umount /mnt/iso 2>/dev/null
    else
        echo "[init] Could not mount $ISO_DEV as iso9660, skipping."
    fi
done

# ── 9. Switch root ─────────────────────────────────────────────
if [ "$ROOT_MOUNTED" = "1" ]; then
    echo ""
    echo "[init] Switching to root filesystem..."

    # Confirm the new root has a usable init binary
    TARGET_INIT=""
    for candidate in /sbin/init /bin/init /init /bin/bash /bin/sh; do
        [ -x "/mnt/root$candidate" ] && TARGET_INIT="$candidate" && break
    done

    if [ -z "$TARGET_INIT" ]; then
        echo "[init] ERROR: No executable init found in new root!"
        echo "[init] Contents of /mnt/root/sbin:"
        ls -la /mnt/root/sbin/ 2>/dev/null || echo "  (empty or missing)"
        echo "[init] Contents of /mnt/root/bin:"
        ls -la /mnt/root/bin/  2>/dev/null || echo "  (empty or missing)"
        echo "[init] Dropping to emergency shell."
    else
        echo "[init] Using init: $TARGET_INIT"

        # Move virtual filesystems into the new root so they survive switch_root.
        # switch_root will free the initramfs RAM, so mounts must be moved first.
        mount --move /proc /mnt/root/proc 2>/dev/null || \
            mount -t proc    proc    /mnt/root/proc
        mount --move /sys  /mnt/root/sys  2>/dev/null || \
            mount -t sysfs   sysfs   /mnt/root/sys
        mount --move /dev  /mnt/root/dev  2>/dev/null || \
            mount -t devtmpfs devtmpfs /mnt/root/dev

        # Hand off to the real root — replaces PID 1 entirely.
        # switch_root: pivots root, frees initramfs, execs TARGET_INIT.
        exec switch_root /mnt/root "$TARGET_INIT"

        # Reaching here means switch_root itself failed.
        echo "[init] FATAL: exec switch_root returned! This should never happen."
        echo "[init] switch_root requires:"
        echo "[init]   - new root to be a real filesystem (not tmpfs/ramfs)"
        echo "[init]   - the target init to be executable"
        echo "[init]   - /mnt/root to be a mountpoint, not a subdirectory"
    fi
fi

# ── 10. Emergency shell ────────────────────────────────────────
# Reached only on failure. Provides a shell for live diagnosis.
echo ""
echo "================================================"
echo "  NextOS — EMERGENCY SHELL"
echo ""
echo "  Root filesystem could NOT be mounted."
echo ""
echo "  Diagnostic commands:"
echo "    dmesg | grep -i 'iso\|loop\|ext4\|sr0'  — kernel messages"
echo "    ls /dev                                  — detected devices"
echo "    mount                                    — active mounts"
echo "    losetup -a                               — loop device status"
echo "    ls /mnt/iso/boot/                        — ISO contents"
echo "    cat /proc/cmdline                        — boot parameters"
echo "================================================"
echo ""
exec /bin/sh
